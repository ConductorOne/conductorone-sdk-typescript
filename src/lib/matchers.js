/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
import { ResponseValidationError } from "../sdk/models/errors/responsevalidationerror.js";
import { SDKError } from "../sdk/models/errors/sdkerror.js";
import { ERR, OK } from "../sdk/types/fp.js";
import { matchResponse, matchStatusCode } from "./http.js";
import { isPlainObject } from "./is-plain-object.js";
const DEFAULT_CONTENT_TYPES = {
    jsonl: "application/jsonl",
    json: "application/json",
    text: "text/plain",
    bytes: "application/octet-stream",
    stream: "application/octet-stream",
    sse: "text/event-stream",
    nil: "*",
    fail: "*",
};
export function jsonErr(codes, schema, options) {
    return { ...options, err: true, enc: "json", codes, schema };
}
export function json(codes, schema, options) {
    return { ...options, enc: "json", codes, schema };
}
export function jsonl(codes, schema, options) {
    return { ...options, enc: "jsonl", codes, schema };
}
export function jsonlErr(codes, schema, options) {
    return { ...options, err: true, enc: "jsonl", codes, schema };
}
export function textErr(codes, schema, options) {
    return { ...options, err: true, enc: "text", codes, schema };
}
export function text(codes, schema, options) {
    return { ...options, enc: "text", codes, schema };
}
export function bytesErr(codes, schema, options) {
    return { ...options, err: true, enc: "bytes", codes, schema };
}
export function bytes(codes, schema, options) {
    return { ...options, enc: "bytes", codes, schema };
}
export function streamErr(codes, schema, options) {
    return { ...options, err: true, enc: "stream", codes, schema };
}
export function stream(codes, schema, options) {
    return { ...options, enc: "stream", codes, schema };
}
export function sseErr(codes, schema, options) {
    return { ...options, err: true, enc: "sse", codes, schema };
}
export function sse(codes, schema, options) {
    return { ...options, enc: "sse", codes, schema };
}
export function nilErr(codes, schema, options) {
    return { ...options, err: true, enc: "nil", codes, schema };
}
export function nil(codes, schema, options) {
    return { ...options, enc: "nil", codes, schema };
}
export function fail(codes) {
    return { enc: "fail", codes };
}
export function match(...matchers) {
    return async function matchFunc(response, request, options) {
        let raw;
        let matcher;
        for (const match of matchers) {
            const { codes } = match;
            const ctpattern = "ctype" in match
                ? match.ctype
                : DEFAULT_CONTENT_TYPES[match.enc];
            if (ctpattern && matchResponse(response, codes, ctpattern)) {
                matcher = match;
                break;
            }
            else if (!ctpattern && matchStatusCode(response, codes)) {
                matcher = match;
                break;
            }
        }
        if (!matcher) {
            return [{
                    ok: false,
                    error: new SDKError("Unexpected Status or Content-Type", {
                        response,
                        request,
                        body: await response.text().catch(() => ""),
                    }),
                }, raw];
        }
        const encoding = matcher.enc;
        let body = "";
        switch (encoding) {
            case "json":
                body = await response.text();
                raw = JSON.parse(body);
                break;
            case "jsonl":
                raw = response.body;
                break;
            case "bytes":
                raw = new Uint8Array(await response.arrayBuffer());
                break;
            case "stream":
                raw = response.body;
                break;
            case "text":
                body = await response.text();
                raw = body;
                break;
            case "sse":
                raw = response.body;
                break;
            case "nil":
                body = await response.text();
                raw = undefined;
                break;
            case "fail":
                body = await response.text();
                raw = body;
                break;
            default:
                encoding;
                throw new Error(`Unsupported response type: ${encoding}`);
        }
        if (matcher.enc === "fail") {
            return [{
                    ok: false,
                    error: new SDKError("API error occurred", { request, response, body }),
                }, raw];
        }
        const resultKey = matcher.key || options?.resultKey;
        let data;
        if ("err" in matcher) {
            data = {
                ...options?.extraFields,
                ...(matcher.hdrs ? { Headers: unpackHeaders(response.headers) } : null),
                ...(isPlainObject(raw) ? raw : null),
                request$: request,
                response$: response,
                body$: body,
            };
        }
        else if (resultKey) {
            data = {
                ...options?.extraFields,
                ...(matcher.hdrs ? { Headers: unpackHeaders(response.headers) } : null),
                [resultKey]: raw,
            };
        }
        else {
            data = {
                ...options?.extraFields,
                ...(matcher.hdrs ? { Headers: unpackHeaders(response.headers) } : null),
            };
        }
        if ("err" in matcher) {
            const result = safeParseResponse(data, (v) => matcher.schema.parse(v), "Response validation failed", { request, response, body });
            return [result.ok ? { ok: false, error: result.value } : result, raw];
        }
        else {
            return [
                safeParseResponse(data, (v) => matcher.schema.parse(v), "Response validation failed", { request, response, body }),
                raw,
            ];
        }
    };
}
const headerValRE = /, */;
/**
 * Iterates over a Headers object and returns an object with all the header
 * entries. Values are represented as an array to account for repeated headers.
 */
export function unpackHeaders(headers) {
    const out = {};
    for (const [k, v] of headers.entries()) {
        out[k] = v.split(headerValRE);
    }
    return out;
}
function safeParseResponse(rawValue, fn, errorMessage, httpMeta) {
    try {
        return OK(fn(rawValue));
    }
    catch (err) {
        return ERR(new ResponseValidationError(errorMessage, {
            cause: err,
            rawValue,
            rawMessage: errorMessage,
            ...httpMeta,
        }));
    }
}
