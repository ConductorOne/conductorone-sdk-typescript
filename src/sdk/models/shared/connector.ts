/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../../lib/primitives.js";
import {
  collectExtraKeys as collectExtraKeys$,
  safeParse,
} from "../../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  ConnectorStatus,
  ConnectorStatus$inboundSchema,
  ConnectorStatus$Outbound,
  ConnectorStatus$outboundSchema,
} from "./connectorstatus.js";
import {
  OAuth2AuthorizedAs,
  OAuth2AuthorizedAs$inboundSchema,
  OAuth2AuthorizedAs$Outbound,
  OAuth2AuthorizedAs$outboundSchema,
} from "./oauth2authorizedas.js";
import {
  OAuth2AuthorizedAsInput,
  OAuth2AuthorizedAsInput$inboundSchema,
  OAuth2AuthorizedAsInput$Outbound,
  OAuth2AuthorizedAsInput$outboundSchema,
} from "./oauth2authorizedasinput.js";

/**
 * Contains an arbitrary serialized message along with a @type that describes the type of the serialized message.
 */
export type Config = {
  /**
   * The type of the serialized message.
   */
  atType?: string | undefined;
  additionalProperties?: { [k: string]: any };
};

/**
 * A Connector is used to sync objects into Apps
 */
export type Connector = {
  /**
   * The id of the app the connector is associated with.
   */
  appId?: string | null | undefined;
  /**
   * The canResumeSync field.
   */
  canResumeSync?: boolean | null | undefined;
  /**
   * The catalogId describes which catalog entry this connector is an instance of. For example, every Okta connector will have the same catalogId indicating it is an Okta connector.
   */
  catalogId?: string | null | undefined;
  config?: Config | null | undefined;
  createdAt?: Date | null | undefined;
  deletedAt?: Date | null | undefined;
  /**
   * The description of the connector.
   */
  description?: string | null | undefined;
  /**
   * The disableCheckBadSync field.
   */
  disableCheckBadSync?: boolean | null | undefined;
  /**
   * The display name of the connector.
   */
  displayName?: string | null | undefined;
  /**
   * The downloadUrl for a spreadsheet if the connector was created from uploading a file.
   */
  downloadUrl?: string | null | undefined;
  /**
   * The id of the connector.
   */
  id?: string | null | undefined;
  oauthAuthorizedAs?: OAuth2AuthorizedAs | null | undefined;
  /**
   * List of profile attributes to sync, when set only these attributes will be synced
   */
  profileAllowList?: Array<string> | null | undefined;
  /**
   * List of profile attributes to ignore (not sync), when set other attributes will be synced, but these will not.
   */
  profileIgnoreList?: Array<string> | null | undefined;
  status?: ConnectorStatus | null | undefined;
  syncDisabledAt?: Date | null | undefined;
  /**
   * The category of the connector sync that was disabled.
   */
  syncDisabledCategory?: string | null | undefined;
  /**
   * The reason the connector sync was disabled.
   */
  syncDisabledReason?: string | null | undefined;
  updatedAt?: Date | null | undefined;
  /**
   * The userIds field is used to define the integration owners of the connector.
   */
  userIds?: Array<string> | null | undefined;
};

/**
 * A Connector is used to sync objects into Apps
 */
export type ConnectorInput = {
  /**
   * The id of the app the connector is associated with.
   */
  appId?: string | null | undefined;
  /**
   * The canResumeSync field.
   */
  canResumeSync?: boolean | null | undefined;
  /**
   * The catalogId describes which catalog entry this connector is an instance of. For example, every Okta connector will have the same catalogId indicating it is an Okta connector.
   */
  catalogId?: string | null | undefined;
  config?: Config | null | undefined;
  createdAt?: Date | null | undefined;
  deletedAt?: Date | null | undefined;
  /**
   * The description of the connector.
   */
  description?: string | null | undefined;
  /**
   * The disableCheckBadSync field.
   */
  disableCheckBadSync?: boolean | null | undefined;
  /**
   * The display name of the connector.
   */
  displayName?: string | null | undefined;
  /**
   * The id of the connector.
   */
  id?: string | null | undefined;
  oauthAuthorizedAs?: OAuth2AuthorizedAsInput | null | undefined;
  /**
   * List of profile attributes to sync, when set only these attributes will be synced
   */
  profileAllowList?: Array<string> | null | undefined;
  /**
   * List of profile attributes to ignore (not sync), when set other attributes will be synced, but these will not.
   */
  profileIgnoreList?: Array<string> | null | undefined;
  status?: ConnectorStatus | null | undefined;
  syncDisabledAt?: Date | null | undefined;
  /**
   * The category of the connector sync that was disabled.
   */
  syncDisabledCategory?: string | null | undefined;
  /**
   * The reason the connector sync was disabled.
   */
  syncDisabledReason?: string | null | undefined;
  updatedAt?: Date | null | undefined;
  /**
   * The userIds field is used to define the integration owners of the connector.
   */
  userIds?: Array<string> | null | undefined;
};

/** @internal */
export const Config$inboundSchema: z.ZodType<Config, z.ZodTypeDef, unknown> =
  collectExtraKeys$(
    z.object({
      "@type": z.string().optional(),
    }).catchall(z.any()),
    "additionalProperties",
    true,
  ).transform((v) => {
    return remap$(v, {
      "@type": "atType",
    });
  });

/** @internal */
export type Config$Outbound = {
  "@type"?: string | undefined;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const Config$outboundSchema: z.ZodType<
  Config$Outbound,
  z.ZodTypeDef,
  Config
> = z.object({
  atType: z.string().optional(),
  additionalProperties: z.record(z.any()),
}).transform((v) => {
  return {
    ...v.additionalProperties,
    ...remap$(v, {
      atType: "@type",
      additionalProperties: null,
    }),
  };
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Config$ {
  /** @deprecated use `Config$inboundSchema` instead. */
  export const inboundSchema = Config$inboundSchema;
  /** @deprecated use `Config$outboundSchema` instead. */
  export const outboundSchema = Config$outboundSchema;
  /** @deprecated use `Config$Outbound` instead. */
  export type Outbound = Config$Outbound;
}

export function configToJSON(config: Config): string {
  return JSON.stringify(Config$outboundSchema.parse(config));
}

export function configFromJSON(
  jsonString: string,
): SafeParseResult<Config, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Config$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Config' from JSON`,
  );
}

/** @internal */
export const Connector$inboundSchema: z.ZodType<
  Connector,
  z.ZodTypeDef,
  unknown
> = z.object({
  appId: z.nullable(z.string()).optional(),
  canResumeSync: z.nullable(z.boolean()).optional(),
  catalogId: z.nullable(z.string()).optional(),
  config: z.nullable(z.lazy(() => Config$inboundSchema)).optional(),
  createdAt: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ).optional(),
  deletedAt: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ).optional(),
  description: z.nullable(z.string()).optional(),
  disableCheckBadSync: z.nullable(z.boolean()).optional(),
  displayName: z.nullable(z.string()).optional(),
  downloadUrl: z.nullable(z.string()).optional(),
  id: z.nullable(z.string()).optional(),
  oauthAuthorizedAs: z.nullable(OAuth2AuthorizedAs$inboundSchema).optional(),
  profileAllowList: z.nullable(z.array(z.string())).optional(),
  profileIgnoreList: z.nullable(z.array(z.string())).optional(),
  status: z.nullable(ConnectorStatus$inboundSchema).optional(),
  syncDisabledAt: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ).optional(),
  syncDisabledCategory: z.nullable(z.string()).optional(),
  syncDisabledReason: z.nullable(z.string()).optional(),
  updatedAt: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ).optional(),
  userIds: z.nullable(z.array(z.string())).optional(),
});

/** @internal */
export type Connector$Outbound = {
  appId?: string | null | undefined;
  canResumeSync?: boolean | null | undefined;
  catalogId?: string | null | undefined;
  config?: Config$Outbound | null | undefined;
  createdAt?: string | null | undefined;
  deletedAt?: string | null | undefined;
  description?: string | null | undefined;
  disableCheckBadSync?: boolean | null | undefined;
  displayName?: string | null | undefined;
  downloadUrl?: string | null | undefined;
  id?: string | null | undefined;
  oauthAuthorizedAs?: OAuth2AuthorizedAs$Outbound | null | undefined;
  profileAllowList?: Array<string> | null | undefined;
  profileIgnoreList?: Array<string> | null | undefined;
  status?: ConnectorStatus$Outbound | null | undefined;
  syncDisabledAt?: string | null | undefined;
  syncDisabledCategory?: string | null | undefined;
  syncDisabledReason?: string | null | undefined;
  updatedAt?: string | null | undefined;
  userIds?: Array<string> | null | undefined;
};

/** @internal */
export const Connector$outboundSchema: z.ZodType<
  Connector$Outbound,
  z.ZodTypeDef,
  Connector
> = z.object({
  appId: z.nullable(z.string()).optional(),
  canResumeSync: z.nullable(z.boolean()).optional(),
  catalogId: z.nullable(z.string()).optional(),
  config: z.nullable(z.lazy(() => Config$outboundSchema)).optional(),
  createdAt: z.nullable(z.date().transform(v => v.toISOString())).optional(),
  deletedAt: z.nullable(z.date().transform(v => v.toISOString())).optional(),
  description: z.nullable(z.string()).optional(),
  disableCheckBadSync: z.nullable(z.boolean()).optional(),
  displayName: z.nullable(z.string()).optional(),
  downloadUrl: z.nullable(z.string()).optional(),
  id: z.nullable(z.string()).optional(),
  oauthAuthorizedAs: z.nullable(OAuth2AuthorizedAs$outboundSchema).optional(),
  profileAllowList: z.nullable(z.array(z.string())).optional(),
  profileIgnoreList: z.nullable(z.array(z.string())).optional(),
  status: z.nullable(ConnectorStatus$outboundSchema).optional(),
  syncDisabledAt: z.nullable(z.date().transform(v => v.toISOString()))
    .optional(),
  syncDisabledCategory: z.nullable(z.string()).optional(),
  syncDisabledReason: z.nullable(z.string()).optional(),
  updatedAt: z.nullable(z.date().transform(v => v.toISOString())).optional(),
  userIds: z.nullable(z.array(z.string())).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Connector$ {
  /** @deprecated use `Connector$inboundSchema` instead. */
  export const inboundSchema = Connector$inboundSchema;
  /** @deprecated use `Connector$outboundSchema` instead. */
  export const outboundSchema = Connector$outboundSchema;
  /** @deprecated use `Connector$Outbound` instead. */
  export type Outbound = Connector$Outbound;
}

export function connectorToJSON(connector: Connector): string {
  return JSON.stringify(Connector$outboundSchema.parse(connector));
}

export function connectorFromJSON(
  jsonString: string,
): SafeParseResult<Connector, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Connector$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Connector' from JSON`,
  );
}

/** @internal */
export const ConnectorInput$inboundSchema: z.ZodType<
  ConnectorInput,
  z.ZodTypeDef,
  unknown
> = z.object({
  appId: z.nullable(z.string()).optional(),
  canResumeSync: z.nullable(z.boolean()).optional(),
  catalogId: z.nullable(z.string()).optional(),
  config: z.nullable(z.lazy(() => Config$inboundSchema)).optional(),
  createdAt: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ).optional(),
  deletedAt: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ).optional(),
  description: z.nullable(z.string()).optional(),
  disableCheckBadSync: z.nullable(z.boolean()).optional(),
  displayName: z.nullable(z.string()).optional(),
  id: z.nullable(z.string()).optional(),
  oauthAuthorizedAs: z.nullable(OAuth2AuthorizedAsInput$inboundSchema)
    .optional(),
  profileAllowList: z.nullable(z.array(z.string())).optional(),
  profileIgnoreList: z.nullable(z.array(z.string())).optional(),
  status: z.nullable(ConnectorStatus$inboundSchema).optional(),
  syncDisabledAt: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ).optional(),
  syncDisabledCategory: z.nullable(z.string()).optional(),
  syncDisabledReason: z.nullable(z.string()).optional(),
  updatedAt: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ).optional(),
  userIds: z.nullable(z.array(z.string())).optional(),
});

/** @internal */
export type ConnectorInput$Outbound = {
  appId?: string | null | undefined;
  canResumeSync?: boolean | null | undefined;
  catalogId?: string | null | undefined;
  config?: Config$Outbound | null | undefined;
  createdAt?: string | null | undefined;
  deletedAt?: string | null | undefined;
  description?: string | null | undefined;
  disableCheckBadSync?: boolean | null | undefined;
  displayName?: string | null | undefined;
  id?: string | null | undefined;
  oauthAuthorizedAs?: OAuth2AuthorizedAsInput$Outbound | null | undefined;
  profileAllowList?: Array<string> | null | undefined;
  profileIgnoreList?: Array<string> | null | undefined;
  status?: ConnectorStatus$Outbound | null | undefined;
  syncDisabledAt?: string | null | undefined;
  syncDisabledCategory?: string | null | undefined;
  syncDisabledReason?: string | null | undefined;
  updatedAt?: string | null | undefined;
  userIds?: Array<string> | null | undefined;
};

/** @internal */
export const ConnectorInput$outboundSchema: z.ZodType<
  ConnectorInput$Outbound,
  z.ZodTypeDef,
  ConnectorInput
> = z.object({
  appId: z.nullable(z.string()).optional(),
  canResumeSync: z.nullable(z.boolean()).optional(),
  catalogId: z.nullable(z.string()).optional(),
  config: z.nullable(z.lazy(() => Config$outboundSchema)).optional(),
  createdAt: z.nullable(z.date().transform(v => v.toISOString())).optional(),
  deletedAt: z.nullable(z.date().transform(v => v.toISOString())).optional(),
  description: z.nullable(z.string()).optional(),
  disableCheckBadSync: z.nullable(z.boolean()).optional(),
  displayName: z.nullable(z.string()).optional(),
  id: z.nullable(z.string()).optional(),
  oauthAuthorizedAs: z.nullable(OAuth2AuthorizedAsInput$outboundSchema)
    .optional(),
  profileAllowList: z.nullable(z.array(z.string())).optional(),
  profileIgnoreList: z.nullable(z.array(z.string())).optional(),
  status: z.nullable(ConnectorStatus$outboundSchema).optional(),
  syncDisabledAt: z.nullable(z.date().transform(v => v.toISOString()))
    .optional(),
  syncDisabledCategory: z.nullable(z.string()).optional(),
  syncDisabledReason: z.nullable(z.string()).optional(),
  updatedAt: z.nullable(z.date().transform(v => v.toISOString())).optional(),
  userIds: z.nullable(z.array(z.string())).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ConnectorInput$ {
  /** @deprecated use `ConnectorInput$inboundSchema` instead. */
  export const inboundSchema = ConnectorInput$inboundSchema;
  /** @deprecated use `ConnectorInput$outboundSchema` instead. */
  export const outboundSchema = ConnectorInput$outboundSchema;
  /** @deprecated use `ConnectorInput$Outbound` instead. */
  export type Outbound = ConnectorInput$Outbound;
}

export function connectorInputToJSON(connectorInput: ConnectorInput): string {
  return JSON.stringify(ConnectorInput$outboundSchema.parse(connectorInput));
}

export function connectorInputFromJSON(
  jsonString: string,
): SafeParseResult<ConnectorInput, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ConnectorInput$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ConnectorInput' from JSON`,
  );
}
