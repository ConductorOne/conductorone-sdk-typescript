/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
import * as z from "zod";
import { remap as remap$ } from "../../../lib/primitives.js";
import { collectExtraKeys as collectExtraKeys$, safeParse, } from "../../../lib/schemas.js";
import { ConnectorStatus$inboundSchema, ConnectorStatus$outboundSchema, } from "./connectorstatus.js";
import { OAuth2AuthorizedAs$inboundSchema, OAuth2AuthorizedAs$outboundSchema, } from "./oauth2authorizedas.js";
import { OAuth2AuthorizedAsInput$inboundSchema, OAuth2AuthorizedAsInput$outboundSchema, } from "./oauth2authorizedasinput.js";
/** @internal */
export const Config$inboundSchema = collectExtraKeys$(z.object({
    "@type": z.string().optional(),
}).catchall(z.any()), "additionalProperties", true).transform((v) => {
    return remap$(v, {
        "@type": "atType",
    });
});
/** @internal */
export const Config$outboundSchema = z.object({
    atType: z.string().optional(),
    additionalProperties: z.record(z.any()),
}).transform((v) => {
    return {
        ...v.additionalProperties,
        ...remap$(v, {
            atType: "@type",
            additionalProperties: null,
        }),
    };
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var Config$;
(function (Config$) {
    /** @deprecated use `Config$inboundSchema` instead. */
    Config$.inboundSchema = Config$inboundSchema;
    /** @deprecated use `Config$outboundSchema` instead. */
    Config$.outboundSchema = Config$outboundSchema;
})(Config$ || (Config$ = {}));
export function configToJSON(config) {
    return JSON.stringify(Config$outboundSchema.parse(config));
}
export function configFromJSON(jsonString) {
    return safeParse(jsonString, (x) => Config$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Config' from JSON`);
}
/** @internal */
export const Connector$inboundSchema = z.object({
    appId: z.nullable(z.string()).optional(),
    canResumeSync: z.nullable(z.boolean()).optional(),
    catalogId: z.nullable(z.string()).optional(),
    config: z.nullable(z.lazy(() => Config$inboundSchema)).optional(),
    createdAt: z.nullable(z.string().datetime({ offset: true }).transform(v => new Date(v))).optional(),
    deletedAt: z.nullable(z.string().datetime({ offset: true }).transform(v => new Date(v))).optional(),
    description: z.nullable(z.string()).optional(),
    disableCheckBadSync: z.nullable(z.boolean()).optional(),
    displayName: z.nullable(z.string()).optional(),
    downloadUrl: z.nullable(z.string()).optional(),
    id: z.nullable(z.string()).optional(),
    oauthAuthorizedAs: z.nullable(OAuth2AuthorizedAs$inboundSchema).optional(),
    profileAllowList: z.nullable(z.array(z.string())).optional(),
    profileIgnoreList: z.nullable(z.array(z.string())).optional(),
    status: z.nullable(ConnectorStatus$inboundSchema).optional(),
    syncDisabledAt: z.nullable(z.string().datetime({ offset: true }).transform(v => new Date(v))).optional(),
    syncDisabledCategory: z.nullable(z.string()).optional(),
    syncDisabledReason: z.nullable(z.string()).optional(),
    updatedAt: z.nullable(z.string().datetime({ offset: true }).transform(v => new Date(v))).optional(),
    userIds: z.nullable(z.array(z.string())).optional(),
});
/** @internal */
export const Connector$outboundSchema = z.object({
    appId: z.nullable(z.string()).optional(),
    canResumeSync: z.nullable(z.boolean()).optional(),
    catalogId: z.nullable(z.string()).optional(),
    config: z.nullable(z.lazy(() => Config$outboundSchema)).optional(),
    createdAt: z.nullable(z.date().transform(v => v.toISOString())).optional(),
    deletedAt: z.nullable(z.date().transform(v => v.toISOString())).optional(),
    description: z.nullable(z.string()).optional(),
    disableCheckBadSync: z.nullable(z.boolean()).optional(),
    displayName: z.nullable(z.string()).optional(),
    downloadUrl: z.nullable(z.string()).optional(),
    id: z.nullable(z.string()).optional(),
    oauthAuthorizedAs: z.nullable(OAuth2AuthorizedAs$outboundSchema).optional(),
    profileAllowList: z.nullable(z.array(z.string())).optional(),
    profileIgnoreList: z.nullable(z.array(z.string())).optional(),
    status: z.nullable(ConnectorStatus$outboundSchema).optional(),
    syncDisabledAt: z.nullable(z.date().transform(v => v.toISOString()))
        .optional(),
    syncDisabledCategory: z.nullable(z.string()).optional(),
    syncDisabledReason: z.nullable(z.string()).optional(),
    updatedAt: z.nullable(z.date().transform(v => v.toISOString())).optional(),
    userIds: z.nullable(z.array(z.string())).optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var Connector$;
(function (Connector$) {
    /** @deprecated use `Connector$inboundSchema` instead. */
    Connector$.inboundSchema = Connector$inboundSchema;
    /** @deprecated use `Connector$outboundSchema` instead. */
    Connector$.outboundSchema = Connector$outboundSchema;
})(Connector$ || (Connector$ = {}));
export function connectorToJSON(connector) {
    return JSON.stringify(Connector$outboundSchema.parse(connector));
}
export function connectorFromJSON(jsonString) {
    return safeParse(jsonString, (x) => Connector$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Connector' from JSON`);
}
/** @internal */
export const ConnectorInput$inboundSchema = z.object({
    appId: z.nullable(z.string()).optional(),
    canResumeSync: z.nullable(z.boolean()).optional(),
    catalogId: z.nullable(z.string()).optional(),
    config: z.nullable(z.lazy(() => Config$inboundSchema)).optional(),
    createdAt: z.nullable(z.string().datetime({ offset: true }).transform(v => new Date(v))).optional(),
    deletedAt: z.nullable(z.string().datetime({ offset: true }).transform(v => new Date(v))).optional(),
    description: z.nullable(z.string()).optional(),
    disableCheckBadSync: z.nullable(z.boolean()).optional(),
    displayName: z.nullable(z.string()).optional(),
    id: z.nullable(z.string()).optional(),
    oauthAuthorizedAs: z.nullable(OAuth2AuthorizedAsInput$inboundSchema)
        .optional(),
    profileAllowList: z.nullable(z.array(z.string())).optional(),
    profileIgnoreList: z.nullable(z.array(z.string())).optional(),
    status: z.nullable(ConnectorStatus$inboundSchema).optional(),
    syncDisabledAt: z.nullable(z.string().datetime({ offset: true }).transform(v => new Date(v))).optional(),
    syncDisabledCategory: z.nullable(z.string()).optional(),
    syncDisabledReason: z.nullable(z.string()).optional(),
    updatedAt: z.nullable(z.string().datetime({ offset: true }).transform(v => new Date(v))).optional(),
    userIds: z.nullable(z.array(z.string())).optional(),
});
/** @internal */
export const ConnectorInput$outboundSchema = z.object({
    appId: z.nullable(z.string()).optional(),
    canResumeSync: z.nullable(z.boolean()).optional(),
    catalogId: z.nullable(z.string()).optional(),
    config: z.nullable(z.lazy(() => Config$outboundSchema)).optional(),
    createdAt: z.nullable(z.date().transform(v => v.toISOString())).optional(),
    deletedAt: z.nullable(z.date().transform(v => v.toISOString())).optional(),
    description: z.nullable(z.string()).optional(),
    disableCheckBadSync: z.nullable(z.boolean()).optional(),
    displayName: z.nullable(z.string()).optional(),
    id: z.nullable(z.string()).optional(),
    oauthAuthorizedAs: z.nullable(OAuth2AuthorizedAsInput$outboundSchema)
        .optional(),
    profileAllowList: z.nullable(z.array(z.string())).optional(),
    profileIgnoreList: z.nullable(z.array(z.string())).optional(),
    status: z.nullable(ConnectorStatus$outboundSchema).optional(),
    syncDisabledAt: z.nullable(z.date().transform(v => v.toISOString()))
        .optional(),
    syncDisabledCategory: z.nullable(z.string()).optional(),
    syncDisabledReason: z.nullable(z.string()).optional(),
    updatedAt: z.nullable(z.date().transform(v => v.toISOString())).optional(),
    userIds: z.nullable(z.array(z.string())).optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var ConnectorInput$;
(function (ConnectorInput$) {
    /** @deprecated use `ConnectorInput$inboundSchema` instead. */
    ConnectorInput$.inboundSchema = ConnectorInput$inboundSchema;
    /** @deprecated use `ConnectorInput$outboundSchema` instead. */
    ConnectorInput$.outboundSchema = ConnectorInput$outboundSchema;
})(ConnectorInput$ || (ConnectorInput$ = {}));
export function connectorInputToJSON(connectorInput) {
    return JSON.stringify(ConnectorInput$outboundSchema.parse(connectorInput));
}
export function connectorInputFromJSON(jsonString) {
    return safeParse(jsonString, (x) => ConnectorInput$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'ConnectorInput' from JSON`);
}
