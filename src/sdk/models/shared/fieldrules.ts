/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  AnyRules,
  AnyRules$inboundSchema,
  AnyRules$Outbound,
  AnyRules$outboundSchema,
} from "./anyrules.js";
import {
  BoolRules,
  BoolRules$inboundSchema,
  BoolRules$Outbound,
  BoolRules$outboundSchema,
} from "./boolrules.js";
import {
  BytesRules,
  BytesRules$inboundSchema,
  BytesRules$Outbound,
  BytesRules$outboundSchema,
} from "./bytesrules.js";
import {
  DoubleRules,
  DoubleRules$inboundSchema,
  DoubleRules$Outbound,
  DoubleRules$outboundSchema,
} from "./doublerules.js";
import {
  DurationRules,
  DurationRules$inboundSchema,
  DurationRules$Outbound,
  DurationRules$outboundSchema,
} from "./durationrules.js";
import {
  EnumRules,
  EnumRules$inboundSchema,
  EnumRules$Outbound,
  EnumRules$outboundSchema,
} from "./enumrules.js";
import {
  Fixed32Rules,
  Fixed32Rules$inboundSchema,
  Fixed32Rules$Outbound,
  Fixed32Rules$outboundSchema,
} from "./fixed32rules.js";
import {
  Fixed64Rules,
  Fixed64Rules$inboundSchema,
  Fixed64Rules$Outbound,
  Fixed64Rules$outboundSchema,
} from "./fixed64rules.js";
import {
  FloatRules,
  FloatRules$inboundSchema,
  FloatRules$Outbound,
  FloatRules$outboundSchema,
} from "./floatrules.js";
import {
  Int32Rules,
  Int32Rules$inboundSchema,
  Int32Rules$Outbound,
  Int32Rules$outboundSchema,
} from "./int32rules.js";
import {
  Int64Rules,
  Int64Rules$inboundSchema,
  Int64Rules$Outbound,
  Int64Rules$outboundSchema,
} from "./int64rules.js";
import {
  MapRules,
  MapRules$inboundSchema,
  MapRules$Outbound,
  MapRules$outboundSchema,
} from "./maprules.js";
import {
  MessageRules,
  MessageRules$inboundSchema,
  MessageRules$Outbound,
  MessageRules$outboundSchema,
} from "./messagerules.js";
import {
  RepeatedRules,
  RepeatedRules$inboundSchema,
  RepeatedRules$Outbound,
  RepeatedRules$outboundSchema,
} from "./repeatedrules.js";
import {
  SFixed32Rules,
  SFixed32Rules$inboundSchema,
  SFixed32Rules$Outbound,
  SFixed32Rules$outboundSchema,
} from "./sfixed32rules.js";
import {
  SFixed64Rules,
  SFixed64Rules$inboundSchema,
  SFixed64Rules$Outbound,
  SFixed64Rules$outboundSchema,
} from "./sfixed64rules.js";
import {
  SInt32Rules,
  SInt32Rules$inboundSchema,
  SInt32Rules$Outbound,
  SInt32Rules$outboundSchema,
} from "./sint32rules.js";
import {
  SInt64Rules,
  SInt64Rules$inboundSchema,
  SInt64Rules$Outbound,
  SInt64Rules$outboundSchema,
} from "./sint64rules.js";
import {
  StringRules,
  StringRules$inboundSchema,
  StringRules$Outbound,
  StringRules$outboundSchema,
} from "./stringrules.js";
import {
  TimestampRules,
  TimestampRules$inboundSchema,
  TimestampRules$Outbound,
  TimestampRules$outboundSchema,
} from "./timestamprules.js";
import {
  UInt32Rules,
  UInt32Rules$inboundSchema,
  UInt32Rules$Outbound,
  UInt32Rules$outboundSchema,
} from "./uint32rules.js";
import {
  UInt64Rules,
  UInt64Rules$inboundSchema,
  UInt64Rules$Outbound,
  UInt64Rules$outboundSchema,
} from "./uint64rules.js";

/**
 * FieldRules encapsulates the rules for each type of field. Depending on the
 *
 * @remarks
 *  field, the correct set should be used to ensure proper validations.
 *
 * This message contains a oneof named type. Only a single field of the following list may be set at a time:
 *   - float
 *   - double
 *   - int32
 *   - int64
 *   - uint32
 *   - uint64
 *   - sint32
 *   - sint64
 *   - fixed32
 *   - fixed64
 *   - sfixed32
 *   - sfixed64
 *   - bool
 *   - string
 *   - bytes
 *   - enum
 *   - repeated
 *   - map
 *   - any
 *   - duration
 *   - timestamp
 */
export type FieldRules = {
  any?: AnyRules | null | undefined;
  bool?: BoolRules | null | undefined;
  bytes?: BytesRules | null | undefined;
  double?: DoubleRules | null | undefined;
  duration?: DurationRules | null | undefined;
  enum?: EnumRules | null | undefined;
  fixed32?: Fixed32Rules | null | undefined;
  fixed64?: Fixed64Rules | null | undefined;
  float?: FloatRules | null | undefined;
  int32?: Int32Rules | null | undefined;
  int64?: Int64Rules | null | undefined;
  map?: MapRules | null | undefined;
  message?: MessageRules | null | undefined;
  repeated?: RepeatedRules | null | undefined;
  sfixed32?: SFixed32Rules | null | undefined;
  sfixed64?: SFixed64Rules | null | undefined;
  sint32?: SInt32Rules | null | undefined;
  sint64?: SInt64Rules | null | undefined;
  string?: StringRules | null | undefined;
  timestamp?: TimestampRules | null | undefined;
  uint32?: UInt32Rules | null | undefined;
  uint64?: UInt64Rules | null | undefined;
};

/** @internal */
export const FieldRules$inboundSchema: z.ZodType<
  FieldRules,
  z.ZodTypeDef,
  unknown
> = z.object({
  any: z.nullable(AnyRules$inboundSchema).optional(),
  bool: z.nullable(BoolRules$inboundSchema).optional(),
  bytes: z.nullable(BytesRules$inboundSchema).optional(),
  double: z.nullable(DoubleRules$inboundSchema).optional(),
  duration: z.nullable(DurationRules$inboundSchema).optional(),
  enum: z.nullable(EnumRules$inboundSchema).optional(),
  fixed32: z.nullable(Fixed32Rules$inboundSchema).optional(),
  fixed64: z.nullable(Fixed64Rules$inboundSchema).optional(),
  float: z.nullable(FloatRules$inboundSchema).optional(),
  int32: z.nullable(Int32Rules$inboundSchema).optional(),
  int64: z.nullable(Int64Rules$inboundSchema).optional(),
  map: z.nullable(z.lazy(() => MapRules$inboundSchema)).optional(),
  message: z.nullable(MessageRules$inboundSchema).optional(),
  repeated: z.nullable(z.lazy(() => RepeatedRules$inboundSchema)).optional(),
  sfixed32: z.nullable(SFixed32Rules$inboundSchema).optional(),
  sfixed64: z.nullable(SFixed64Rules$inboundSchema).optional(),
  sint32: z.nullable(SInt32Rules$inboundSchema).optional(),
  sint64: z.nullable(SInt64Rules$inboundSchema).optional(),
  string: z.nullable(StringRules$inboundSchema).optional(),
  timestamp: z.nullable(TimestampRules$inboundSchema).optional(),
  uint32: z.nullable(UInt32Rules$inboundSchema).optional(),
  uint64: z.nullable(UInt64Rules$inboundSchema).optional(),
});

/** @internal */
export type FieldRules$Outbound = {
  any?: AnyRules$Outbound | null | undefined;
  bool?: BoolRules$Outbound | null | undefined;
  bytes?: BytesRules$Outbound | null | undefined;
  double?: DoubleRules$Outbound | null | undefined;
  duration?: DurationRules$Outbound | null | undefined;
  enum?: EnumRules$Outbound | null | undefined;
  fixed32?: Fixed32Rules$Outbound | null | undefined;
  fixed64?: Fixed64Rules$Outbound | null | undefined;
  float?: FloatRules$Outbound | null | undefined;
  int32?: Int32Rules$Outbound | null | undefined;
  int64?: Int64Rules$Outbound | null | undefined;
  map?: MapRules$Outbound | null | undefined;
  message?: MessageRules$Outbound | null | undefined;
  repeated?: RepeatedRules$Outbound | null | undefined;
  sfixed32?: SFixed32Rules$Outbound | null | undefined;
  sfixed64?: SFixed64Rules$Outbound | null | undefined;
  sint32?: SInt32Rules$Outbound | null | undefined;
  sint64?: SInt64Rules$Outbound | null | undefined;
  string?: StringRules$Outbound | null | undefined;
  timestamp?: TimestampRules$Outbound | null | undefined;
  uint32?: UInt32Rules$Outbound | null | undefined;
  uint64?: UInt64Rules$Outbound | null | undefined;
};

/** @internal */
export const FieldRules$outboundSchema: z.ZodType<
  FieldRules$Outbound,
  z.ZodTypeDef,
  FieldRules
> = z.object({
  any: z.nullable(AnyRules$outboundSchema).optional(),
  bool: z.nullable(BoolRules$outboundSchema).optional(),
  bytes: z.nullable(BytesRules$outboundSchema).optional(),
  double: z.nullable(DoubleRules$outboundSchema).optional(),
  duration: z.nullable(DurationRules$outboundSchema).optional(),
  enum: z.nullable(EnumRules$outboundSchema).optional(),
  fixed32: z.nullable(Fixed32Rules$outboundSchema).optional(),
  fixed64: z.nullable(Fixed64Rules$outboundSchema).optional(),
  float: z.nullable(FloatRules$outboundSchema).optional(),
  int32: z.nullable(Int32Rules$outboundSchema).optional(),
  int64: z.nullable(Int64Rules$outboundSchema).optional(),
  map: z.nullable(z.lazy(() => MapRules$outboundSchema)).optional(),
  message: z.nullable(MessageRules$outboundSchema).optional(),
  repeated: z.nullable(z.lazy(() => RepeatedRules$outboundSchema)).optional(),
  sfixed32: z.nullable(SFixed32Rules$outboundSchema).optional(),
  sfixed64: z.nullable(SFixed64Rules$outboundSchema).optional(),
  sint32: z.nullable(SInt32Rules$outboundSchema).optional(),
  sint64: z.nullable(SInt64Rules$outboundSchema).optional(),
  string: z.nullable(StringRules$outboundSchema).optional(),
  timestamp: z.nullable(TimestampRules$outboundSchema).optional(),
  uint32: z.nullable(UInt32Rules$outboundSchema).optional(),
  uint64: z.nullable(UInt64Rules$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FieldRules$ {
  /** @deprecated use `FieldRules$inboundSchema` instead. */
  export const inboundSchema = FieldRules$inboundSchema;
  /** @deprecated use `FieldRules$outboundSchema` instead. */
  export const outboundSchema = FieldRules$outboundSchema;
  /** @deprecated use `FieldRules$Outbound` instead. */
  export type Outbound = FieldRules$Outbound;
}

export function fieldRulesToJSON(fieldRules: FieldRules): string {
  return JSON.stringify(FieldRules$outboundSchema.parse(fieldRules));
}

export function fieldRulesFromJSON(
  jsonString: string,
): SafeParseResult<FieldRules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FieldRules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FieldRules' from JSON`,
  );
}
